name: ðŸš€ CD - Deploy to EC2

on:
  push:
    branches: [main]
  workflow_run:
    workflows: ["ðŸ” CI - Code Quality & Tests"]
    types:
      - completed

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and push Docker image
  build-and-push:
    name: ðŸ—ï¸ Build & Push Docker Image
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'push' }}

    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: ðŸ“š Checkout code
        uses: actions/checkout@v4

      - name: ðŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“‹ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ðŸ—ï¸ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          target: runner

  # Deploy to EC2
  deploy:
    name: ðŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: ðŸ“š Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Configure SSH
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: ðŸ“‚ Copy deployment files to EC2
        run: |
          scp -i ~/.ssh/deploy_key -r docker-compose.prod.yml nginx/ ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/fotomandalin/

      - name: ðŸš€ Deploy application on EC2
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            cd ~/fotomandalin
            
            # Create .env file from secrets
            cat > .env.production << EOL
            # Database
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            
            # Application
            NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            
            # Payment
            IYZICO_API_KEY=${{ secrets.IYZICO_API_KEY }}
            IYZICO_SECRET_KEY=${{ secrets.IYZICO_SECRET_KEY }}
            IYZICO_BASE_URL=${{ secrets.IYZICO_BASE_URL }}
            
            # AWS
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_REGION=${{ secrets.AWS_REGION }}
            AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}
            
            # Email
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USER=${{ secrets.SMTP_USER }}
            SMTP_PASS=${{ secrets.SMTP_PASS }}
            
            # SSL
            SSL_EMAIL=${{ secrets.SSL_EMAIL }}
            DOMAIN=${{ secrets.DOMAIN }}
            EOL
            
            # Login to GitHub Container Registry
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # Pull latest image
            docker pull ${{ needs.build-and-push.outputs.image-tag }}
            
            # Stop existing containers
            docker-compose -f docker-compose.prod.yml --env-file .env.production down
            
            # Update the image tag in docker-compose file
            sed -i 's|ghcr.io/${{ github.repository }}:.*|${{ needs.build-and-push.outputs.image-tag }}|g' docker-compose.prod.yml
            
            # Start services
            docker-compose -f docker-compose.prod.yml --env-file .env.production up -d
            
            # Wait for application to be ready
            echo "Waiting for application to start..."
            sleep 30
            
            # Run database migrations
            docker-compose -f docker-compose.prod.yml --env-file .env.production exec -T app npx prisma migrate deploy
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully! ðŸŽ‰"
          EOF

      - name: ðŸ” Health Check
        run: |
          # Wait a bit more for the application to fully start
          sleep 10

          # Check if the application is responding
          for i in {1..5}; do
            if curl -f "https://${{ secrets.DOMAIN }}/api/health" || curl -f "http://${{ secrets.EC2_HOST }}:3000/api/health"; then
              echo "âœ… Application is healthy!"
              break
            else
              echo "âŒ Health check failed, attempt $i/5"
              if [ $i -eq 5 ]; then
                echo "âŒ Application failed to start properly"
                exit 1
              fi
              sleep 10
            fi
          done

      - name: ðŸ“Š Deployment Summary
        run: |
          echo "ðŸŽ‰ Deployment Summary:"
          echo "- Image: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "- Target: ${{ secrets.EC2_HOST }}"
          echo "- Domain: ${{ secrets.DOMAIN }}"
          echo "- Time: $(date)"

  # Notification (optional)
  notify:
    name: ðŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: ðŸ“¢ Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "âœ… Deployment to EC2 was successful!"
            echo "ðŸŒ Application is live at: https://${{ secrets.DOMAIN }}"
          else
            echo "âŒ Deployment failed!"
            echo "Please check the logs for more information."
          fi
